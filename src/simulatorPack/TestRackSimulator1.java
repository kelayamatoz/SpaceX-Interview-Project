package simulatorPack;
import java.awt.geom.Point2D;
import java.util.ArrayList;

import abstractModulePack.AbstractSignalModule;

/**
 * TestRackSimulator1 simulates a test-rack that: 
 * 
 * 1. outputs data to four-ports simultaneously.
 * 
 * 2. starts to output data at -10dbm.
 * 
 * 3. after every measurement, the output power is decremented by 2dbm.
 * 
 * 4. stops outputting power at -30dbm.
 * 
 *  We assume that the load resistance is 1ohm. There is a random noise that ranges from 0 - 0.001 volts. 
 *  
 *  The simulator splits its signal to four pieces and sends over four ports.
 * @author tianzhao
 *
 */

public class TestRackSimulator1 extends AbstractSignalModule{
	private final double maxEnergy = -10,
						 minEnergy = -30,
						 step = 2,
						 frequencyInGHz = 2.4,
						 timeStepInNanosec = 0.025,
						 noiseRange = 0.001; 
	private double lastEnergy,
				   lastTimeInNanosec,
				   omegaInGRad; 
				   
	private ArrayList<ArrayList<Point2D.Double>> pointsArray;
	
	public TestRackSimulator1(String signalGeneratorName, String xAxisName,	String yAxisName, int numOfPorts) {
		super(signalGeneratorName, xAxisName, yAxisName, numOfPorts);
		super.disableReadingFromAllPorts();
		lastEnergy = maxEnergy;
		lastTimeInNanosec = 0;
		omegaInGRad = 2 * Math.PI * frequencyInGHz;
		
		/* Sets up the structure for reading data */
		pointsArray = new ArrayList<ArrayList<Point2D.Double>>();
		for (int i = 0; i < 4; i ++) {
			pointsArray.add(new ArrayList<Point2D.Double>());
		}
	}
	
	public TestRackSimulator1() {
		super("Simulator 1", "Time in nanosecond", "Amplitude in volts", 4);
		lastEnergy = maxEnergy;
		lastTimeInNanosec = 0;
		omegaInGRad = 2 * Math.PI * frequencyInGHz;
		
		/* Sets up the structure for reading data */
		pointsArray = new ArrayList<ArrayList<Point2D.Double>>();
		for (int i = 0; i < 4; i ++) {
			pointsArray.add(new ArrayList<Point2D.Double>());
		}
	}

	/** 
	 * This function simulates the process of configuring data connection
	 * between the test-rack and the software
	 */
	@Override
	public boolean configureConnection() {
		/* 
		 * Simply let the current thread sleep for 300 ms to simulate the 
		 * time needed for establishing connection
		 */
		try {
			Thread.currentThread();
			Thread.sleep(300);
		} catch (InterruptedException e) {
			System.out.println("Error: coule not put current thread to sleep");
			e.printStackTrace();
		}
		
		return true;
	}

	/**
	 * This function simulates getting data from 
	 * a real signal generator. 
	 */
	@SuppressWarnings("unchecked")
	@Override
	public boolean getDataFromDevice() {
		/* 
		 * Simply let the current thread sleep for 300 ms to simulate the 
		 * time needed for getting data from the signal generator
		 */
		if ((!this.canGenerateData() || lastEnergy < minEnergy)) {
			this.disableReadingFromAllPorts();
			return false;
		}
		
		try {
			Thread.currentThread();
			Thread.sleep(300);
		} catch (InterruptedException e) {
			System.out.println("Error: could not put current thread to sleep");
			e.printStackTrace();
		}
		
		/* 
		 * Simulating the case where a sine wave is splitted into four ports.Therefore energy at each
		 * single port is divided by 4. 
		 */
		double sineWaveEnergy = lastEnergy - Math.log10(4);
		System.out.print("Energy = ");
		System.out.println(sineWaveEnergy);
		double amplitude = Math.sqrt(2 * Math.pow(10, ((sineWaveEnergy - 30) / 10)));
		/*
		 *  Generates a CW tone at 2.4GHz. The average power of the 
		 * CW tone is lastEnergy. 
		 * I plan to generate 20 points per one period. 
		 */
		for	(int i = 0; i < this.getDataBufferSize(); i ++) {
			double voltage = amplitude * Math.sin(omegaInGRad * lastTimeInNanosec);
			// use a random number generator to simulate the noise in the output data
			pointsArray.get(0).add(new Point2D.Double(lastTimeInNanosec, voltage - /*0.01*/ + Math.random() * noiseRange));
			pointsArray.get(1).add(new Point2D.Double(lastTimeInNanosec, voltage + /*0.01*/ + Math.random() * noiseRange));
			pointsArray.get(2).add(new Point2D.Double(lastTimeInNanosec, voltage + /*0.02*/ + Math.random() * noiseRange));
			pointsArray.get(3).add(new Point2D.Double(lastTimeInNanosec, voltage - /*0.02*/ + Math.random() * noiseRange));
			lastTimeInNanosec += timeStepInNanosec;
			/* simulating as if it takes 1 mils to read a data point from the signal generator */
			try {
				Thread.currentThread();
				Thread.sleep(1);
			} catch (InterruptedException e) {
				System.out.println("Error: coule not put current thread to sleep");
				e.printStackTrace();
			}
		}
		
		// store data generated by the simulator
		for (int j = 0; j < 4; j ++) {
			this.prepareDataForReading(j, (ArrayList<Point2D.Double>) pointsArray.get(j).clone());
		}
		
		// reset for reading new points
		for (int k = 0; k < 4; k ++) {
			pointsArray.get(k).clear();
		}
		
		lastEnergy -= step;
		this.enableReadingFromAllPorts();
		return true;
	}

	@Override
	public boolean reset() {
		this.lastEnergy = this.maxEnergy;
		this.lastTimeInNanosec = 0;
		/*
		pointsArray = new ArrayList<ArrayList<Point2D.Double>>();
		for (int i = 0; i < 4; i ++) {
			pointsArray.add(new ArrayList<Point2D.Double>());
		}
		*/
		
		return true;
	}
}
